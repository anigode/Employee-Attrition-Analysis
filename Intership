#importing library
import pandas as pd
import numpy as np
from scipy import stats
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report, accuracy_score
# Load the dataset
data = pd.read_csv('/content/greendestination (1) (1).csv')
data.head()
data.describe()
columns = data.columns.tolist()
columns
data.isnull().sum()
data.isnull()
# Inspect unique values in 'Attrition' and 'OverTime'
print(data['Attrition'].unique())
print(data['OverTime'].unique())
# Convert 'Attrition' and 'OverTime' columns to numerical
data['Attrition'] = data['Attrition'].map({'Yes': 1, 'No': 0})
data['OverTime'] = data['OverTime'].map({'Yes': 1, 'No': 0})
problematic_columns = [
    'Age', 'DailyRate', 'DistanceFromHome', 'HourlyRate', 'MonthlyIncome',
    'MonthlyRate', 'PercentSalaryHike', 'TotalWorkingYears',
    'YearsAtCompany', 'YearsInCurrentRole', 'YearsSinceLastPromotion',
    'YearsWithCurrManager'
]
zero_issues = data[problematic_columns] == 0
zero_issues_summary = zero_issues.sum()

print("Zero value issues before cleaning:")
print(zero_issues_summary)
for column in problematic_columns:
    median_value = data[data[column] != 0][column].median()
    data[column] = data[column].replace(0, median_value)
# Check for duplicate rows
data.drop_duplicates(inplace=True)
# Check data types
print("Data types before conversion:")
print(data.dtypes)

# Convert data types if necessary (example: converting 'EmployeeNumber' to string)
data['EmployeeNumber'] = data['EmployeeNumber'].astype(str)
# Add other conversions as necessary
# Define expected ranges and filter data accordingly
expected_ranges = {
    'Age': (18, 65),
    'DailyRate': (1, float('inf')),
    'DistanceFromHome': (1, float('inf')),
    'HourlyRate': (1, float('inf')),
    'MonthlyIncome': (1, float('inf')),
    'MonthlyRate': (1, float('inf')),
    'PercentSalaryHike': (0, 100),
    'TotalWorkingYears': (0, 50),
    'YearsAtCompany': (0, 50),
    'YearsInCurrentRole': (0, 50),
    'YearsSinceLastPromotion': (0, 50),
    'YearsWithCurrManager': (0, 50)
}

for column, (min_value, max_value) in expected_ranges.items():
    data = data[(data[column] >= min_value) & (data[column] <= max_value)]
# Save the cleaned dataset
data.to_csv('cleaned_dataset_final.csv', index=False)
# Calculate attrition rate
attrition_rate = data['Attrition'].mean() * 100
print(f'Attrition Rate: {attrition_rate:.2f}%')
# Check the shapes and lengths of y_test and y_pred
print(f'y_test shape: {y_test.shape}, y_pred shape: {y_pred.shape}')

# Check the indices or any other identifiers to see if they match up
# For example, print a sample of y_test and y_pred to compare
print(f'Sample of y_test: {y_test.head()}')
print(f'Sample of y_pred: {y_pred[:5]}')  # Adjust this based on the length of your data

# Identify where the mismatch occurs and adjust accordingly
# Ensure y_pred corresponds to the samples in y_test after any preprocessing or modeling staeps
from sklearn.preprocessing import LabelEncoder

# Example: Label encoding for specific columns
label_encoder = LabelEncoder()

# Assuming 'Over18' is a categorical column that needs encoding
data['Over18'] = label_encoder.fit_transform(data['Over18'])

# Verify all categorical columns are encoded
categorical_columns = ['BusinessTravel', 'Department', 'EducationField', 'Gender', 'JobRole', 'MaritalStatus']
for col in categorical_columns:
    if data[col].dtype == 'object':  # Check if the column is categorical (string/object type)
        data[col] = label_encoder.fit_transform(data[col])

# Split features and target variable
X = data.drop('Attrition', axis=1)
y = data['Attrition']

# Split the data into training and testing sets
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Building and training the model
from sklearn.linear_model import LogisticRegression
model = LogisticRegression(max_iter=1000)
model.fit(X_train, y_train)

# Predictions
y_pred = model.predict(X_test)

# Evaluation
from sklearn.metrics import classification_report, accuracy_score
print(classification_report(y_test, y_pred))
print(f'Accuracy: {accuracy_score(y_test, y_pred):.2f}')

